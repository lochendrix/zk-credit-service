# Zero-Knowledge Credit Score Verification Service

![Rust](https://img.shields.io/badge/rust-%23000000.svg?style=for-the-badge&logo=rust&logoColor=white)
![Docker](https://img.shields.io/badge/docker-%230db7ed.svg?style=for-the-badge&logo=docker&logoColor=white)
![Redis](https://img.shields.io/badge/redis-%23DD0031.svg?style=for-the-badge&logo=redis&logoColor=white)

This project is a proof-of-concept for a privacy-preserving financial service that allows a third party (e.g., a bank) to verify that a user's credit score is above a certain threshold, without ever revealing the actual score.

It uses [Bulletproofs](https://crypto.stanford.edu/bulletproofs/), an efficient Zero-Knowledge Proof (ZKP) system, to generate cryptographic proofs for range-based statements. The entire system is built in Rust as a scalable, containerized application.

---

## System Architecture

The main service (`zkp-service`) is designed as a distributed, asynchronous system to handle computationally expensive proof generation without blocking incoming requests.


1.  A client sends a verification request to the API Frontend.
2.  The API immediately creates a job, pushes it onto a Redis Queue, and returns a job_id to the client.
3.  One or more Prover Workers are constantly listening to the queue. A free worker picks up the job.
4.  The worker performs the computationally intensive proof generation and stores the final result (the proof or an error) in a Redis Store using the job_id as the key.
5.  The client polls the API's GET endpoint with the job_id to retrieve the final result once it's available.

---

## Tech Stack

| Category           | Technology                                                                                             |
| ------------------ | ------------------------------------------------------------------------------------------------------ |
| **Language** | [Rust](https://www.rust-lang.org/)                                                                     |
| **Cryptography** | [Bulletproofs](https://crypto.stanford.edu/bulletproofs/)                                              |
| **Backend** | [Axum](https://github.com/tokio-rs/axum)                                                               |
| **Messaging** | [Redis](https://redis.io/)                                                                             |
| **Containerization**| [Docker](https://www.docker.com/) & [Docker Compose](https://docs.docker.com/compose/)                 |

---

## Project Structure

This repository is a monorepo containing two main projects:

* `zkp-service/`: The main, containerized, multi-service application.
    * `zk_api/`: The lightweight Axum web server that handles client requests.
    * `zk_core/`: The prover worker that performs the heavy cryptographic lifting.
    * `zk_common/`: A shared library for data structures used by both the API and the worker.
* `verifier-service/`: A standalone command-line application that demonstrates how a third party can independently verify a proof generated by the service.

---

## How to Run

**Prerequisites:** Docker and Docker Compose must be installed.

1.  **Navigate to the Service Directory:**
    From the root of the repository, change into the `zkp-service` directory.
    ```bash
    cd zkp-service
    ```

2.  **Build and Run with Docker Compose:**
    Run the following command. This will build the Docker images for the API and worker, and start all three containers (api, worker, redis).
    ```bash
    docker-compose up --build
    ```
    You will see logs from all three services streaming in your terminal. The API will be available at `http://localhost:3000`.

3.  **To Stop the Services:**
    Press `Ctrl + C` in the terminal, and then run `docker-compose down` to clean up the containers and network.

---

## How to Use

Use a tool like `curl` to interact with the API.

1.  **Submit a Verification Request:**
    Send a POST request with the user's (mock) score and the threshold to verify against.
    ```bash
    curl -X POST -H "Content-Type: application/json" \
    -d '{"user_id": "user-123", "score": 750, "threshold": 700}' \
    http://localhost:3000/v1/verifications
    ```
    The API will respond immediately with a job_id:
    ```json
    {"job_id":"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"}
    ```

2.  **Check the Result:**
    Use the job_id from the previous step to poll the GET endpoint.
    ```bash
    curl http://localhost:3000/v1/verifications/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
    ```
    * If the worker is still processing, you will get a `404 Not Found`.
    * Once complete, you will get a `200 OK` with the final proof:
        ```json
        {
          "status": "COMPLETED",
          "error_message": null,
          "proof_b64": "AOF...lots_of_random_characters...=",
          "commitment_b64": "xyz...more_random_characters...=="
        }
        ```

---

## How to Run the Independent Verifier

This demonstrates the "zero-knowledge" aspect. The verifier application can confirm the proof is valid without trusting the service or knowing the secret score.

1.  **Navigate to the Verifier Directory:**
    In a separate terminal, from the root of the repository, change into the `verifier-service` directory.
    ```bash
    cd verifier-service
    ```

2.  **Run the Verifier Application:**
    ```bash
    cargo run
    ```
    The application will start and wait for you to paste the JSON output from the API.

3.  **Verify a Proof:**
    * Copy the entire JSON object from a successful API call (the one with the proof_b64 data).
    * Paste it into the terminal where the verifier is running.
    * Send the "End of File" signal:
        * **macOS / Linux:** `Ctrl + D`
        * **Windows:** `Ctrl + Z` then `Enter`

    The verifier will instantly process the proof and print the result:
    ```bash
    --- Verification Result ---
    SUCCESS: The proof is cryptographically valid. The user's score is confirmed to be >= 700.
    ````
